<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on ChaosBlog</title>
    <link>https://blog.networkchallenge.de/tags/docker/</link>
    <description>Recent content in Docker on ChaosBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>de-de</language>
    <copyright>Copyright © ChaosBlog 2018</copyright>
    <lastBuildDate>Fri, 19 Apr 2019 20:50:00 +1200</lastBuildDate>
    
	<atom:link href="https://blog.networkchallenge.de/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Google Cloud Run ausprobiert</title>
      <link>https://blog.networkchallenge.de/post/google-cloud-run-ausprobiert/</link>
      <pubDate>Fri, 19 Apr 2019 20:50:00 +1200</pubDate>
      
      <guid>https://blog.networkchallenge.de/post/google-cloud-run-ausprobiert/</guid>
      <description>Abstract Ich befasse mich mit einem Java-Microservice, welches bei Google Cloud Run deployed wird und betrachte es als Alternative zu AWS Lambda. Dabei gehe ich auch auf das Thema Kaltstartzeit der Container ein und befasse mich in diesem Kontext auch mit den Vorteilen der GraalVM.
Google Cloud Next 2019 Dieses Jahr hat Google auf der eigenen Cloud-Messe Cloud Next wieder einige interessante Dinge vorgestellt, darunter Google Cloud Run. Cloud Run ermöglicht den Betrieb von Containern als HTTP-Endpunkte nur für die Zeit eines Requests.</description>
    </item>
    
    <item>
      <title>MongoDB-Cluster Verbindung durch Firewall</title>
      <link>https://blog.networkchallenge.de/post/mongodb_verbindung_hinter_firewall/</link>
      <pubDate>Sun, 23 Sep 2018 15:52:41 +0200</pubDate>
      
      <guid>https://blog.networkchallenge.de/post/mongodb_verbindung_hinter_firewall/</guid>
      <description>Auf Arbeit stand ich vor dem Problem, auf einem MongoDB Atlas-Cluster einen Dump einspielen zu müssen. Dafür ist aber die Benutzung der Kommandozeilenwerkzeuge mongodump und mongorestore unabdingbar. Die Herausforderung war aber eine, die mich regelmäßig quält: das Sicherheitsbedürfnis des Unternehmens steht an oberster Stelle und wir müssen somit immer über den Unternehmens-Proxy oder dedizierte Jumphosts gehen, die für bestimmte Verbindungen freigeschaltet sind.
Bei der Verbindung zu einem Replica Set steht man vor der Herausforderung, dass der Client eine Verbindung zu allen Nodes machen will und bekommt dabei die Serveradressen von der Gegenseite mitgeteilt.</description>
    </item>
    
    <item>
      <title>Automatische Docker-Mounts in Windows</title>
      <link>https://blog.networkchallenge.de/post/automatische-docker-mounts-win/</link>
      <pubDate>Wed, 22 Feb 2017 09:22:51 +0100</pubDate>
      
      <guid>https://blog.networkchallenge.de/post/automatische-docker-mounts-win/</guid>
      <description>Standardmäßig wird bei der Installation der Docker Toolbox die freie Virtualisierungssoftware VirtualBox installiert. Um nun im Docker-Container auf Dateien des Windows-Hosts zuzugreifen, wird standardmäßig der Pfad /c/Users im Gastsystem gemountet. Dies ist aber nicht optimal, da man als Windows-Nutzer oft mit Leerzeichen in Pfaden geplagt ist und auch sonst eher z.B. mit einem anderen Arbeitsverzeichnis z.B. c:\dev arbeitet.
Damit dies nun bei jedem Start der Docker-Machine verfügbar ist, müssen ein paar manuelle Handgriffe getätigt werden.</description>
    </item>
    
  </channel>
</rss>